<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[无向图Tarjan入门]]></title>
    <url>%2Fgavinzheng%2F2018%2F10%2F23%2F24602%2F</url>
    <content type="text"><![CDATA[前言Tarjan算法常用来求解无向图中割边/割点问题。 割边：删去这条边，连通块个数会增加的边。 割点：删去这个点，连通块个数会增加的点。 DFS树：从任意一点开始DFS，经过的所有边和经过的所有点连成的一棵树就叫DFS树。 dfn[x]：指节点x的dfn序（即在DFS中第几个走到） Tarjan算法要求的前置技能并不多。但是重边的问题必须严谨处理，否则很容易写挂。 追溯值：low[x]Tarjan算法引入了追溯值low[x].设以x为根的子树为subtree(x).low[x]定义为以下结点的DFN的最小值：（与Tarjan有向图中的low[x]区分） subtree(x)中的结点 通过一条不在搜索树上的边能到达subtree(x)的结点。 不难发现，low[i]按搜索树的递归遍历顺序是单调递增的，因此可以在回溯的过程中求出low[i].]]></content>
      <tags>
        <tag>Tarjan</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区间重叠问题]]></title>
    <url>%2Fgavinzheng%2F2018%2F10%2F20%2F25904%2F</url>
    <content type="text"><![CDATA[前言区间重叠问题有很多种情况。这里简单介绍几种。 单点被区间覆盖问题给定一些区间，查询一个点被多少个区间覆盖。 很明显，我们可以用差分的思路来解决。定义$d$为差分数组 当要将一段区间$[l,r]$进行修改时(这里假设操作为给区间加上1)，我们只需要给$d[l]$加上1，然后给$d[r]$减掉1。若两区间边界点重叠的情况（即$区间[1].r==区间[2].l$）算有交点，那么就应该给$d[r+1]$减掉1。想想为什么。 这样，我们在所有操作结束后，只需要对$d$求一次前缀和即可。 需要注意的是，这种区间修改操作只能应用于操作完成后进行查询的情况。 其他查询修改交错进行的情况请使用线段树来防止TLE 修改复杂度$O(1)$ 查询复杂度$O(1)$ 修改后需要O(n)预处理才能再次查询 区间交点问题给定一些区间，求特定区间与多少个其他区间有重叠部分 其实这道题只需要使用前缀和（以及后缀和）即可。定义$pre$记录前缀和，$suf$记录后缀和，要求解的区间为$[l,r]$。 首先，对于所有区间的右端点求前缀和，$pre[r]$则为这个特定区间前面所有的完整区间。 同理，对于所有区间的左端点取后缀和，$suf[l]$则为这个特定区间后面所有的完整区间。 那我们只需要用$n-pre[l]-suf[r]$即可求出答案。($n$为总区间数)]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>区间</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018初赛准备]]></title>
    <url>%2Fgavinzheng%2F2018%2F10%2F13%2F11873%2F</url>
    <content type="text"><![CDATA[理论知识二叉树基本性质1、一棵二叉树的第i层有$2^{i-1}$个节点 2、一共有i层的满二叉树/一颗i层的二叉树最多有$2^{i}-1$个节点 知中序和后序遍历求前序遍历因为后序遍历的最后一个一定是整棵树的根，所以我们在后序遍历中找到主根，并且找出它在中序遍历中的位置。那么在他左边的就是第一颗子树，右边的就是第二颗子树。再回到后序遍历找第一颗子树的根即可。 例如：后序 DGJHEBIFCA 中序 DBGEHJACIF 主树根：A 左子树根: B 右子树根:C 组合数学-插板法字符串的子串个数注意！空串也算一个子串！！！ 所以一个长度为n的字符串的字串个数为$n!+1$]]></content>
      <categories>
        <category>Uncategorized</category>
      </categories>
      <tags>
        <tag>初赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学基础]]></title>
    <url>%2Fgavinzheng%2F2018%2F10%2F07%2F26357%2F</url>
    <content type="text"><![CDATA[质数筛法埃氏筛法不解释，定义一个数组flag,枚举每个数 $i$ ，若 $flag[i]=1$ ，则 $i$ 是一个质数。当 $i$ 为质数是，进行赋值操作: $flag[j\times i]_{1 \leq j\times i \leq n}=1$ 。即将每个素数的倍数标记为和数。 模板题 POJ2689 参考代码: 123456789101112int prime[maxn];int prime_cnt;bool flag[maxn]=&#123;0&#125;;void get_prime(int n)&#123; flag[1]=1; for(int i=2;i&lt;=n;i++)&#123; if(flag[i])continue; prime[++prime_cnt]=i; for(int j=2;j*i&lt;=n;j++) flag[j*i]=1; &#125; return;&#125; 线性筛]]></content>
      <categories>
        <category>Uncategorized</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
</search>
