<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[洛谷P3376]]></title>
    <url>%2Fgavinzheng%2F2019%2F01%2F19%2F31964%2F</url>
    <content type="text"><![CDATA[【模板】网络最大流EK版1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;#define maxn 10500#define inf (int)(1e9+100)int head[maxn];struct gg&#123; int u,v,w,next;&#125;side[100020*2];int cnt=1;int maxflow=0;void insert(int u,int v,int w)&#123; side[++cnt]=(gg)&#123;u,v,w,head[u]&#125;; head[u]=cnt;&#125;int n,m,s,t,pre[maxn],incf[maxn];bool visit[maxn];bool bfs()&#123; queue&lt;int&gt;line; incf[s]=inf; memset(visit,0,sizeof(visit)); visit[s]=1;line.push(s); while(!line.empty())&#123; int now=line.front();line.pop(); for(int i=head[now];i;i=side[i].next)&#123; int tar=side[i].v,w=side[i].w; if(visit[tar]||w==0)continue; incf[tar]=min(incf[now],w); visit[tar]=1;pre[tar]=i; line.push(tar);if(tar==t)&#123;return 1;&#125; &#125; &#125; return 0;&#125;void update()&#123; maxflow+=incf[t]; for(int i=t;i!=s;i=side[pre[i]^1].v)&#123; side[pre[i]].w-=incf[t]; side[pre[i]^1].w+=incf[t]; &#125; return;&#125;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t); for(int i=1;i&lt;=m;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); insert(u,v,w);insert(v,u,0); &#125; while(bfs())&#123;update();&#125; cout&lt;&lt;maxflow; return 0;&#125; Dinic版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;#define maxn 10500#define maxm 105000#define inf (1e9+1000)int head[maxn];int cnt=1;struct gg&#123; int u,v,w,next;&#125;side[maxm*2];int n,m,s,t,rk[maxn];void insert(int u,int v,int w)&#123; side[++cnt]=(gg)&#123;u,v,w,head[u]&#125;;head[u]=cnt;return;&#125;int maxflow=0;bool bfs()&#123; memset(rk,0,sizeof(rk)); rk[s]=1; queue&lt;int&gt;line;line.push(s); while(!line.empty())&#123; int now=line.front();line.pop(); for(int i=head[now];i;i=side[i].next)&#123; int tar=side[i].v; if(!side[i].w)continue; if(rk[tar])continue; rk[tar]=rk[now]+1;line.push(tar); &#125; &#125; if(rk[t])return 1; return 0;&#125;int dfs(int now,int flow)&#123; if(now==t)&#123;return flow;&#125; int rest=flow;int tot=0; for(int i=head[now];i;i=side[i].next)&#123; int tar=side[i].v,w=side[i].w; if(!w||rk[now]+1!=rk[tar])continue; int used=dfs(tar,min(w,rest));rest-=used;tot+=used; side[i].w-=used;side[i^1].w+=used; &#125; return tot;&#125;void dinic()&#123; while(bfs())&#123; maxflow+=dfs(s,inf); &#125;&#125;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t); for(int i=1;i&lt;=m;i++)&#123; int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w); insert(u,v,w);insert(v,u,0); &#125; dinic(); cout&lt;&lt;maxflow; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1231]]></title>
    <url>%2Fgavinzheng%2F2019%2F01%2F19%2F1743%2F</url>
    <content type="text"><![CDATA[Luogu1231 教辅的组成两个小trick刚刚写过了网络流模板。准备来写一点练习题。刚拿到这道题其实比较懵。完全找不到入手点。经过学习，我发现网络流操作有两个小trick。 1.加入虚拟源点和汇点。通过虚拟源点和汇点，来将几个图（或几个组合）变成一个有向图，就能在上面跑网络流了。 2.建立虚拟“点对”。因为网络流可以限制每条边的流量不超过容量限制。但是却不能限制每个点经过的流量。这时候我们就需要将任意一个点$x$都生成一个对应点$x’$。并建立一个$x-&gt;x’$的有向边（容量为1）。所有入边连接在$x$上，所有出边连接在$x’$上。这样，任意一个经过点$x$的流都会被$x-&gt;x’$这条边限制，使得只有一条边经过点$x$。大概就是这个样子 思路点的处理我们首先把数组开成双倍空间，那么一下就是所有点在数组中的编号。这里设$N=N1+N2+N3$ 1~N1 对应N1(书的个数) N1+1~N1+N2 对应N2（练习册的个数） N1+N2+1~N1+N2+N3 对应N3（答案的个数） $\forall x,index[x’]=index[x]+N$ 点表示完后，我们就可以处理边了。 边的处理还是按照网络流基本操作来做。但是网络流存边有个小问题。那就是邻接表的$cnt$初值必须要设为1。才能在$++cnt$时保证成对变换的匹配性。 代码EK版一开始听了一个叫hwy的混蛋。写了个EK。长这样的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define maxn 100500#define inf (int)(1e9+1000)#define maxm 100500bool visit[maxn];int head[maxn],pre[maxn];int cnt=1,m1,m2,n,n1,n2,n3,incf[maxn],maxflow;int s=90401,t=90402;struct gg&#123; int u,v,w,next;&#125;side[maxm*4];void insert(int u,int v,int w)&#123;// if(u==3)&#123;// int gg=1;// &#125; side[++cnt]=(gg)&#123;u,v,w,head[u]&#125;; head[u]=cnt;&#125;inline int num(int type,int num)&#123;//三种type分别代表书，练习册，答案。重复代表映射点。 if(type==1)return num; if(type==2)return n1+num; if(type==3)return n1+n2+num; if(type==11)return num+n; if(type==22)return n1+num+n; if(type==33)return n1+n2+num+n; return 0;&#125;bool bfs()&#123; memset(visit,0,sizeof(visit)); incf[s]=inf;visit[s]=1; queue&lt;int&gt;line;line.push(s); while(!line.empty())&#123; int now=line.front();line.pop(); for(int i=head[now];i;i=side[i].next)&#123; int tar=side[i].v;int w=side[i].w; if(visit[tar]||!w)continue; incf[tar]=min(incf[now],1); visit[tar]=1;pre[tar]=i; line.push(tar);if(tar==t)return 1; &#125; &#125; return 0;&#125;void update()&#123; maxflow+=incf[t]; for(int i=t;i!=s;i=side[pre[i]^1].v)&#123;// cout&lt;&lt;i&lt;&lt;endl; side[pre[i]].w-=incf[t]; side[pre[i]^1].w+=incf[t]; &#125; return;&#125;int main()&#123;// freopen("in.txt","r",stdin); scanf("%d%d%d%d",&amp;n1,&amp;n2,&amp;n3,&amp;m1); n=n1+n2+n3; for(int i=1;i&lt;=n;i++)&#123;//建立映射点对 insert(i,i+n,1); insert(i+n,i,0); &#125; for(int i=1;i&lt;=n2;i++)&#123;//建立源点所有练习册的连接 insert(s,num(2,i),1); insert(num(2,i),s,0); &#125; for(int i=1;i&lt;=n3;i++)&#123;//建立所有答案和汇点的连接 insert(num(33,i),t,1); insert(t,num(33,i),0); &#125; for(int i=1;i&lt;=m1;i++)&#123; int x,y;scanf("%d%d",&amp;x,&amp;y); insert(num(22,y),num(1,x),1);//将练习册的映射点和书相连 insert(num(1,x),num(22,y),0); &#125; scanf("%d",&amp;m2); for(int i=1;i&lt;=m2;i++)&#123; int x,y;scanf("%d%d",&amp;x,&amp;y); insert(num(11,x),num(3,y),1);//将书的映射点和答案相连。 insert(num(3,y),num(11,x),0); &#125; while(bfs())&#123;update();&#125; cout&lt;&lt;maxflow; return 0;&#125; 然后。。。 滚回去学Dinic Dinic版12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;#define maxn 10500#define maxm 105000#define inf (1e9+1000)int head[maxn];int cnt=1;struct gg&#123; int u,v,w,next;&#125;side[maxm*2];int n,m,s,t,rk[maxn];void insert(int u,int v,int w)&#123; side[++cnt]=(gg)&#123;u,v,w,head[u]&#125;;head[u]=cnt;return;&#125;int maxflow=0;bool bfs()&#123; memset(rk,0,sizeof(rk)); rk[s]=1; queue&lt;int&gt;line;line.push(s); while(!line.empty())&#123; int now=line.front();line.pop(); for(int i=head[now];i;i=side[i].next)&#123; int tar=side[i].v; if(!side[i].w)continue; if(rk[tar])continue; rk[tar]=rk[now]+1;line.push(tar); &#125; &#125; if(rk[t])return 1; return 0;&#125;int dfs(int now,int flow)&#123; if(now==t)&#123;return flow;&#125; int rest=flow;int tot=0; for(int i=head[now];i;i=side[i].next)&#123; int tar=side[i].v,w=side[i].w; if(!w||rk[now]+1!=rk[tar])continue; int used=dfs(tar,min(w,rest));rest-=used;tot+=used; side[i].w-=used;side[i^1].w+=used; &#125; return tot;&#125;void dinic()&#123; while(bfs())&#123; maxflow+=dfs(s,inf); &#125;&#125;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t); for(int i=1;i&lt;=m;i++)&#123; int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w); insert(u,v,w);insert(v,u,0); &#125; dinic(); cout&lt;&lt;maxflow; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Luogu</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流初步]]></title>
    <url>%2Fgavinzheng%2F2019%2F01%2F11%2F2855%2F</url>
    <content type="text"><![CDATA[网络流初步前言在实际生活中常常会遇到一下类型的问题： 有一张管道组成的输水/输电/输气网络。每个管道都是单向的，并且有一个流量限制（超过流量限制就会爆管）。很明显，如果我们要通过这张网络将一种物品从起点输送到终点，不能将每个管道都满流（因为网络的瓶颈部分可能会炸）。那么每个管道的流量就需要精密规划了。 一个网络可以用来模拟道路系统的交通量、管中的液体、电路中的电流或类似一些东西在一个结点的网络中游动的任何事物。 摘自 维基百科 基本术语和定义为了方便，网络流中有一些基本术语： 容量-c （Capacity）：指这条油箱边最多承受的流量 流-f （Flow）：字面意 源点-s (Source）：起点 汇点-t （Sink）：终点 增广路：若一条从源点到汇点的路径上所有边的剩余容量都大于0，这条路被称为增广路 另外，我们引入两个集合$V$和$E$。分别代表点的集合以及边的集合。 那么很显然，我们可以把流量定义为：$f(u,v)$。其中$u \in V,v \in V$。 也可以把容量表示为： c(u,v)。其中$u \in V, v \in V$ 流的限制 容量限制：$f(u,v) \leq c(u,v)$ 斜对称性：f(u,v)=-f(v,u) 流守恒性：$\forall x \in V-{s,t},\sum_{(u,x)\in E}{f(u,x)}=\sum_{(x,v)}{f(x,v)} $ 第一点不解释（流量过多管子会炸） 第二点暂且可以用初中物理来解释：在一个一维数轴上，向前100个单位等同于向后100个单位。 从一个结点 s 到另一个结点 t 的净流量一定是从 t 到 s 净流量的相反数。 摘自 维基百科 第三点用人话来解释就是：除了源点和汇点,每个点流入流量之和等于流出流量之和。 最大流定义最大化$\sum_{(s,v) \in E}{f(s,v)}$ 意思就是一个流函数$f$的集合，是源点流出的流的和最大。 解法FF(FORD-FULKERSON)即通过寻找增广路来不停更新最大流。 但是，如果直接傻呵呵的DFS。可能会出现一下状况： 那么为了解决这个问题，我们可以引入一个叫取消流的操作。 在代码实现反向建边中，我们可以将所有边都建成双向边。并将初始边的权值记为容量。每次“反向建边”就只用将这条边的权值减去流量，再在反向边加上这个流量。这样就能保证$f(u,v)+f(v,u)=c(u,v)$。我们可以利用成对变换来实现。0x01_位运算：成对变换 至于为什么这样反向建边可以求出正解，我们可以感性理解一下： 反向建边其实是提供了“取消流”这个操作。在初始状态，我们的流不能走一条反向边，因为根本不存在这条边。但是如果我们的流走了一条正向边，与之对应的反向边就是可以“走”的了。之所以这里的走打了引号，是因为我们并没有直接走反向边（也没办法直接走），而是通过取消已经走过了的正向边的流来达到相同的效果。 这就是残余网络 至于如何理性证明： 在代码实现层面，我们可以通过两种算法来实现FF。 EK(Edmonds-Krap)即使用BFS寻找增广路（这样就可以找到当前状态下最短的增广路）。 定义一个$pre[]$数组，记录在BFS时每个点的前驱。从源点开始BFS，当BFS到汇点时就停止，并且按照$pre[]$数组的标记回溯，反向建边。并清空队列，重新开始搜索。当无法BFS到汇点时就停止。此时的答案就是正确答案。 复杂度：EKEK 算法的时间复杂度为$O(nm^2)$。我们可以证明最多需要 $O(nm)$次増广可以达到最大流，每次増广的复杂度为 $O(m)$。绝大多数情况下这个复杂度都跑不满 。 ——Siyuan 例题：洛谷P3376【模板】网络最大流 题解 Dinic我们可以发现，EK在面对很多情况时会TLE。于是我们默默的掏出了Dinic。 Dinic的主要思路就是建立分层图。先用记录每个点的层数$rk$,即从源点最少走多少条边走到当前点。 当$rk[t]=0$时，很明显的就找完了所有的增广路。 每次找到层数后，就开始从源点DFS。 如果要DFS进入下层，我们就需要满足： \left\{\begin{matrix} rk[v]=rk[u]+1\\ w(u,v) \end{matrix}\right.对于DFS树上的每一个点，我们从父节点传递一个flow，代表“楼上”分配给当前节点的流量，并记录一个resr，代表当前节点还能给子节点分配的流量。很明显，初始情况下$rest = flow$。 另外提一句，因为是DFS,所以在EK中的“update”操作我们就可以在DFS的返回过程中实现。 DinicDinic 算法的时间复杂度为 $O(n^2m)$。我们可以证明最多需要建立 $O(n)$ 个层次图，每次建立层次图的复杂度为 $O(m)$。接下来分析 DFS 的复杂度，每次最多増广 $O(m)$ 次，每次修改流量的复杂度为 $O(n)$，所以 DFS 的复杂度为$ O(nm)$。再加上$ O(n)$ 个层次图，总复杂度为 $O(n^2m)$。绝大多数情况下这个复杂度都跑不满。 ——Siyuan 例题：洛谷P3376【模板】网络最大流 题解 PR(PUSH-RELABLE)预留推进法/推送-重贴标签法留坑待填 参考资料 sshwy_网络流初步 PKU_网络流算法 维基百科_网络流 Siyuan_网络流 - 最大流]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CH0201]]></title>
    <url>%2Fgavinzheng%2F2018%2F12%2F15%2F59029%2F</url>
    <content type="text"><![CDATA[CH0201 费解的开关描述你玩过“拉灯”游戏吗？25盏灯排成一个5x5的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。 我们用数字“1”表示一盏开着的灯，用数字“0”表示关着的灯。下面这种状态 1011101101101111000011011 在改变了最左上角的灯的状态后将变成： 0111111101101111000011011 再改变它正中间的灯后状态将变成： 0111111001110011010011011 给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。 输入格式​ 第一行有一个正整数n，代表数据中共有n个待解决的游戏初始状态。​ 以下若干行数据分为n组，每组数据有5行，每行5个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。​ 对于30%的数据，n&lt;=5；​ 对于100%的数据，n&lt;=500。 输出格式​ 输出数据一共有n行，每行有一个小于等于6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。​ 对于某一个游戏初始状态，若6步以内无法使所有灯变亮，请输出“-1”。 样例输入1234567891011121314151617183001110101110001110101110011101111011111011111111110111111111111111111111111 样例输出12332-1 来源Matrix67 思路这道题很明显是一个暴力（5*5的方格）。我们考虑一下枚举每一次操作的位置。复杂度是$ 500\times(5 \times 5 )^{6}$是要炸的。 我们可以再想一下优化：当一行中哪些点要使用操作已经确定时，要删掉这一行中剩余的1，我们只能在下一行的对应位置使用“操作”。 那很容易可以想到，只需要确定第一行，那么就可以确定第二行。确定第二行就可以确定第三行。所以只需要枚举第一行初始状态就可以了，复杂度$O(2^{5}n)$。 至于枚举状态，我们可以用上一章学到的位运算来枚举。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int map[10][10];int ori[10][10];void work(int data,int line)&#123;//确定标记点后开始标记 for(int i=1;i&lt;=5;i++)&#123; if((1&lt;&lt;(i-1))&amp;data)&#123; map[line][i+1]^=1; map[line][i-1]^=1; map[line][i]^=1; map[line+1][i]^=1; &#125; &#125; return;&#125;void solve()&#123; int mi=(int)(1e9);char a[10]; for(int i=1;i&lt;=5;i++)&#123; scanf("%s",a); for(int j=1;j&lt;=5;j++)ori[i][j]=a[j-1]-'0'; &#125; for(int i=0;i&lt;(1&lt;&lt;5);i++)&#123; for(int j=1;j&lt;=5;j++)for(int k=1;k&lt;=5;k++)map[j][k]=ori[j][k]; int ans=0; int g=i;while(g)&#123;g&amp;=(g-1);ans++;&#125;//统计第一行几个标记 work(i,1);//将第一行标记 for(int j=2;j&lt;=5;j++)&#123;//确定第j行要如何标记 int mark=0; for(int k=1;k&lt;=5;k++)&#123; if(!map[j-1][k])&#123; mark|=1&lt;&lt;(k-1);ans++; &#125; &#125; work(mark,j);//标记这一行 &#125; int test=0; for(int i=1;i&lt;=5;i++)test+=map[5][i]; if(test==5)mi=min(ans,mi); &#125; if(mi&gt;6)mi=-1; printf("%d\n",mi); return;&#125;int main()&#123; int n;scanf("%d",&amp;n); while(n--)&#123; solve(); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Contest_Hunter</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0x02-枚举-模拟-递推]]></title>
    <url>%2Fgavinzheng%2F2018%2F12%2F15%2F13136%2F</url>
    <content type="text"></content>
      <categories>
        <category>征途_算法竞赛进阶指南</category>
        <category>0x00_基础算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CH0103]]></title>
    <url>%2Fgavinzheng%2F2018%2F12%2F01%2F10212%2F</url>
    <content type="text"><![CDATA[0103 最短Hamilton路径描述给定一张 n(n≤20) 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。 输入格式第一行一个整数n。 接下来n行每行n个整数，其中第i行第j个整数表示点i到j的距离（一个不超过10^7的正整数，记为a[i,j]）。 对于任意的x,y,z，数据保证 a[x,x]=0，a[x,y]=a[y,x] 并且 a[x,y]+a[y,z]&gt;=a[x,z]。 输出格式一个整数，表示最短Hamilton路径的长度。 样例输入1234540 2 1 32 0 2 11 2 0 13 1 1 0 样例输出14 样例解释从0到3的Hamilton路径有两条，0-1-2-3和0-2-1-3。前者的长度为2+2+1=5，后者的长度为1+2+1=4 解法对于这道题，n的数据范围很容易引起注意。这个范围一般是搜索或者状压吧？ 那我们考虑一下如何压缩状态。这道题说的是每个点经过且经过一次。 那我们只需要一个int来储存即可。 定义$f[i][j]$为状态为i（走过的点对应的二进制位数为1，反之为0），当前在第j个点的最短路径长度。 在这里我们可以选用填表法。 当i的第j位为1时就可以枚举一下k，当i的第k位也是1时就可以使用这个方程转移了，$f[i][j]=min(f[i][j],f[i\;xor\;(1&lt;&lt;j)][k]+w[k][j])$ 其中$i\;xor\;1&lt;&lt;j$就是将i的第j位改成0。那么这个方程的状态转移就是从k走到j。 所以最终的答案就是$f[(1&lt;&lt;n)-1][n]$，即所有点都走过且现在在第n个点时的最短路。 代码实现12345678910111213141516171819202122232425262728293031323334//可能跟博客中的有些细节不同//这份代码是从1开始编号的#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define inf (int)(1e9+1000)int f[(1&lt;&lt;20)+10][30];int w[30][30];int main()&#123; int n;cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; for(int h=1;h&lt;=n;h++)&#123; cin&gt;&gt;w[i][h]; &#125; &#125; for(int i=1;i&lt;=(1&lt;&lt;20)+5;i++)&#123; for(int h=0;h&lt;=25;h++)f[i][h]=inf; &#125; f[1][1]=0; for(int i=1;i&lt;=(1&lt;&lt;n)-1;i++)&#123;//枚举状态 for(int j=1;j&lt;=n;j++)&#123;//枚举现在是在哪个点 if(!(i&amp;1&lt;&lt;(j-1)))continue; for(int k=1;k&lt;=n;k++)&#123;//枚举由哪个点更新而来 if(!(i&amp;1&lt;&lt;(k-1))||j==k)continue; f[i][j]=min(f[i][j],f[i^(1&lt;&lt;(j-1))][k]+w[k][j]); &#125; &#125; &#125; cout&lt;&lt;f[(1&lt;&lt;(n))-1][n]; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Contest_Hunter</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CH0102]]></title>
    <url>%2Fgavinzheng%2F2018%2F12%2F01%2F59173%2F</url>
    <content type="text"><![CDATA[CH0102 64位整数乘法求 a 乘 b 对 p 取模的值，其中 1≤a,b,p≤10^18。 输入格式第一行a，第二行b，第三行p。 输出格式一个整数，表示a*b mod p的值。 样例输入123239 样例输出16 解法很明显，两个ll乘在一起会炸掉。我们很容易想到可以用高精乘。但是高精乘写出来太麻烦了。我们就有了另外一个方法。 先将a分解为k二进制的乘积形式：$\sum _{i=0}^{k} c_{i} \times 2^{i}$其中c为1或0。 那么a*b就可以分成$\sum _{i=0}^{k} c_{i} \times 2^{i} \times a$ 那么，当i=0时，我们很容易计算上式的值为$c_{0}\times 2^{0} \times a$，设$x_{0}= 2^{0} \times a=a$ 那么，当i=1时，很容易得到$2^{1}\times a=x\times2=x_{1}$ 。 因为对于所有的x，都是小于等于$10^{18}$的，但是对于ll的范围是$2^{63}$（64位整数，其中一个是符号位），大概是$9\times10^{18}$,又因为在计算x的过程中最大值也只会是$2\times 10^{18}$所以不会炸。 那么很容易推得$ans=\sum_{i=0}^{k} c_{i}\times x_{i} $ 其中c为0或1。代表这个二进制位为0或1。 代码实现123456789101112131415#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define ll long longll a,b,p;int main()&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;ll ans=0; for(;a;a&gt;&gt;=1)&#123;//遍历a的每个二进制位 if(a&amp;1)&#123;ans+=b;ans%=p;&#125;//若当前最低位为1,累计当前答案,这里的b为博客中的x b*=2;b%=p; &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Contest_Hunter</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0x01_位运算]]></title>
    <url>%2Fgavinzheng%2F2018%2F12%2F01%2F28374%2F</url>
    <content type="text"><![CDATA[0x01 位运算使用位运算的意义 提高程序运行效率（常数优化） 降低编程复杂度（让程序简单易懂） 四种算数位运算基本语法即“与，或，异或，非”。 按位与_&amp; 如果两个相应的二进制位都为1，则该位的结果值为1，否则为0。 按位或_| 两个相应的二进制位中只要有一个为1，该位的结果值为1。 按位异或_^ 若参加运算的两个二进制位值相同则为0，否则为1 所以称之为“异或”嘛QAQ 取反_~ ~是一元运算符，用来对一个二进制数按位取反，即将0变1，将1 一些小trick1.x&amp;=(x-1)消除一个二进制数最后一个1 123x=1100x-1=1011x&amp;(x-1)=1000 当然 我们用这个方法还可以检测一个数是不是2的幂次。 当一个二进制数只有一个1时（即2的幂次），进行这个操作得到的就会是0。 2.二进制枚举子集 思路就是使用一个正整数二进制表示的第i位是1还是0，代表集合的第i个数取或者不取。所以从0到2^n-1总共2^n个整数，正好对应集合的2^n个子集。 123456789101112131415161718192021222324252627282930S = &#123;1,2,3&#125;N bit Combination0 000 &#123;&#125;1 001 &#123;1&#125;2 010 &#123;2&#125;3 011 &#123;1,2&#125;4 100 &#123;3&#125;5 101 &#123;1,3&#125;6 110 &#123;2,3&#125;7 111 &#123;1,2,3&#125;//参考代码#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n=5;//集合中有5个元素 for(int i=0; i&lt;(1&lt;&lt;n); i++) //从0～2^5-1个状态 &#123; for(int j=0; j&lt;n; j++) //遍历二进制的每一位 &#123; if(i&amp;(1&lt;&lt;j))//判断二进制第j位是否存在 &#123; printf("%d ",j);//如果存在输出第j个元素 &#125; &#125; printf("\n"); &#125; return 0;&#125; 3.对二进制数上的某一位进行修改​ 将int型变量a的第k位清0，即a=a&amp;~(1&lt;&lt;k)​ 将int型变量a的第k位置1， 即a=a|(1&lt;&lt;k) 4.x为0或1，对x进行状态转换x^=1 移位运算左移即乘上2。 $1&lt;&lt;n=2^{n} $ $n&lt;&lt;1=2n$ 算术右移即除以2。 $n&gt;&gt;1=\left \lfloor \frac{n}{2.0} \right \rfloor$ 即除以2向零取整。 成对变换在图论算法中常常需要用到无向边，在代码实现层面其实就是两条有向边。 如果我们需要简单的找到一条边的返向边，我们就可以用到成对变换。 因为xor是一个很神奇的运算。设$x \space xor \space 1=y$，那么一定有$y\space xor \space 1=x$。 如果我们需要调用x的反向边，直接调用$x \space xor \space 1$就能实现。存储和调用时都按照这种规则即可。 参考资料位运算——强大得令人害怕 二进制枚举子集详解 看完这个你的位运算学得就差不多了]]></content>
      <categories>
        <category>征途_算法竞赛进阶指南</category>
        <category>0x00_基础算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对拍和随机数生成]]></title>
    <url>%2Fgavinzheng%2F2018%2F11%2F06%2F13427%2F</url>
    <content type="text"><![CDATA[对拍12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; const string file = "cake"; const string checker = file + "_"; const string Input = file + ".in"; const string stdOutput = file + ".ans"; const string Output = file + ".out"; while (1) &#123; system(("./mk &gt; " + Input).data()); system(("./" + checker + " &lt; " + Input + " &gt; " + stdOutput).data()); double st = clock(); system(("./" + file + " &lt; " + Input + " &gt; " + Output).data()); double ed = clock(); if (system(("diff " + Output + " " + stdOutput).data())) &#123; printf("WA\n"); break; &#125; else &#123; if (ed - st &gt; 1000) &#123; printf("TLE %f ms", ed - st); break; &#125; else printf("AC %f ms\n", ed - st); &#125; &#125;&#125; 随机数生成12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int random(int x) &#123; ll res = rand(); res = res * res; return res % x + 1;&#125;int random(int l, int r) &#123; ll res = random(r); while (res &lt; l) res = random(r); return res;&#125;int main() &#123; srand((int)(new char)); const int n = 7, q = 300; printf("%d %d\n", n, q); for (int i = 1; i &lt;= n; ++ i) &#123; printf("%d ", random(100)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Uncategorized</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[无向图Tarjan入门]]></title>
    <url>%2Fgavinzheng%2F2018%2F10%2F23%2F24602%2F</url>
    <content type="text"><![CDATA[前言Tarjan算法常用来求解无向图中割边/割点问题。 割边：删去这条边，连通块个数会增加的边。 割点：删去这个点，连通块个数会增加的点。 DFS树：从任意一点开始DFS，经过的所有边和经过的所有点连成的一棵树就叫DFS树。 dfn[x]：指节点x的dfn序（即在DFS中第几个走到） Tarjan算法要求的前置技能并不多。但是重边的问题必须严谨处理，否则很容易写挂。 正文追溯值：low[x]Tarjan算法引入了追溯值low[x].设以x为根的子树为subtree(x).low[x]定义为以下结点的DFN的最小值：（与Tarjan有向图中的low[x]区分） subtree(x)中的结点 通过一条不在搜索树上的边能到达subtree(x)的结点。（即对于subtree(x)，只走“返祖边”能到达的节点） 不难发现，low[i]按搜索树的递归遍历顺序是单调递增的，因此可以在回溯的过程中求出low[i]. 模板123456789101112131415int dfn[N],low[N],dfn_cnt;int ans[N],cnt;void tarjan(int k,int p)&#123;//tarjan，k指当前节点，p指上一个节点（即DFS树上的父节点） dfn[k]=low[k]=++dfn_cnt; for(int i=h[k];i;i=e[i].nex)&#123; int u=e[i].t; if(！dfn[u])&#123;//u这个节点没被遍历 tarjan(u,k);//搜索下去 low[k]=min(low[k],low[u]);//追溯值按定义取low &#125; else &#123; if(u!=p)low[k]=min(low[k],dfn[u]);//当不为父节点时，可以更新。 &#125; &#125;&#125; 判定割边令x是y的父节点，则满足dfn[x]]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>Tarjan</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区间重叠问题]]></title>
    <url>%2Fgavinzheng%2F2018%2F10%2F20%2F25904%2F</url>
    <content type="text"><![CDATA[前言区间重叠问题有很多种情况。这里简单介绍几种。 单点被区间覆盖问题给定一些区间，查询一个点被多少个区间覆盖。 很明显，我们可以用差分的思路来解决。定义$d$为差分数组 当要将一段区间$[l,r]$进行修改时(这里假设操作为给区间加上1)，我们只需要给$d[l]$加上1，然后给$d[r]$减掉1。若两区间边界点重叠的情况（即$区间[1].r==区间[2].l$）算有交点，那么就应该给$d[r+1]$减掉1。想想为什么。 这样，我们在所有操作结束后，只需要对$d$求一次前缀和即可。 需要注意的是，这种区间修改操作只能应用于操作完成后进行查询的情况。 其他查询修改交错进行的情况请使用线段树来防止TLE 修改复杂度$O(1)$ 查询复杂度$O(1)$ 修改后需要O(n)预处理才能再次查询 区间交点问题给定一些区间，求特定区间与多少个其他区间有重叠部分 其实这道题只需要使用前缀和（以及后缀和）即可。定义$pre$记录前缀和，$suf$记录后缀和，要求解的区间为$[l,r]$。 首先，对于所有区间的右端点求前缀和，$pre[r]$则为这个特定区间前面所有的完整区间。 同理，对于所有区间的左端点取后缀和，$suf[l]$则为这个特定区间后面所有的完整区间。 那我们只需要用$n-pre[l]-suf[r]$即可求出答案。($n$为总区间数)]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>区间</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018初赛准备]]></title>
    <url>%2Fgavinzheng%2F2018%2F10%2F13%2F11873%2F</url>
    <content type="text"><![CDATA[理论知识二叉树基本性质1、一棵二叉树的第i层有$2^{i-1}$个节点 2、一共有i层的满二叉树/一颗i层的二叉树最多有$2^{i}-1$个节点 知中序和后序遍历求前序遍历因为后序遍历的最后一个一定是整棵树的根，所以我们在后序遍历中找到主根，并且找出它在中序遍历中的位置。那么在他左边的就是第一颗子树，右边的就是第二颗子树。再回到后序遍历找第一颗子树的根即可。 例如：后序 DGJHEBIFCA 中序 DBGEHJACIF 主树根：A 左子树根: B 右子树根:C 组合数学-插板法字符串的子串个数注意！空串也算一个子串！！！ 所以一个长度为n的字符串的字串个数为$n!+1$]]></content>
      <categories>
        <category>Uncategorized</category>
      </categories>
      <tags>
        <tag>初赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学基础]]></title>
    <url>%2Fgavinzheng%2F2018%2F10%2F07%2F26357%2F</url>
    <content type="text"><![CDATA[质数筛法埃氏筛法不解释，定义一个数组flag,枚举每个数 $i$ ，若 $flag[i]=1$ ，则 $i$ 是一个质数。当 $i$ 为质数是，进行赋值操作: $flag[j\times i]_{1 \leq j\times i \leq n}=1$ 。即将每个素数的倍数标记为和数。 模板题 POJ2689 参考代码: 123456789101112int prime[maxn];int prime_cnt;bool flag[maxn]=&#123;0&#125;;void get_prime(int n)&#123; flag[1]=1; for(int i=2;i&lt;=n;i++)&#123; if(flag[i])continue; prime[++prime_cnt]=i; for(int j=2;j*i&lt;=n;j++) flag[j*i]=1; &#125; return;&#125; 线性筛]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
</search>
